// Fastbreak Compiler Specification
// Compiler pipeline, lexer, semantic analysis, and quality requirements
module fastbreak.compiler

use fastbreak::{
    Specification,
    Span,
    Identifier,
    Attribute,
    ModuleRegistry,
}

// ============================================================================
// State: Compiler Pipeline
// ============================================================================

state CompilerPipeline {
    source_files: Set<String>,
    parsed_specs: Map<String, Specification>,
    errors: List<String>,

    invariant "All parsed specs have source files" {
        forall path in parsed_specs.keys() =>
            path in source_files
    }
}

// ============================================================================
// Actions: Compiler Operations
// ============================================================================

action parse(source: String) -> Result<Specification, String>
    ensures {
        match result {
            Ok(spec) => spec.types.len() >= 0,
            Err(msg) => msg.len() > 0,
        }
    }

action analyze(spec: Specification) -> List<String>
    ensures {
        // Returns list of semantic errors (empty if valid)
        result.len() >= 0
    }

action compile(spec: Specification) -> CompiledSpec
    requires {
        // Specification must pass semantic analysis
        analyze(spec).len() == 0
    }

action generate_markdown(spec: CompiledSpec) -> String
    ensures {
        result.len() > 0
    }

action generate_diagram(spec: CompiledSpec, diagram_type: DiagramType) -> String
    ensures {
        result.len() > 0
    }

action build_module_registry(specs: List<Specification>) -> ModuleRegistry
    ensures {
        // All modules from input specs are registered
        forall spec in specs where spec.module is Some =>
            result.modules.contains_key(spec.module.unwrap().path)
    }

action resolve_imports(registry: ModuleRegistry, module_name: String) -> List<String>
    requires {
        registry.modules.contains_key(module_name)
    }
    ensures {
        // Returns list of unresolved import errors (empty if all resolved)
        result.len() >= 0
    }

// ============================================================================
// Supporting Types for Actions
// ============================================================================

type CompiledSpec {
    name: String,
    structs: List<CompiledStruct>,
    enums: List<CompiledEnum>,
    states: List<CompiledState>,
    actions: List<CompiledAction>,
    scenarios: List<CompiledScenario>,
    properties: List<CompiledProperty>,
}

type CompiledStruct {
    name: String,
    fields: List<CompiledField>,
}

type CompiledField {
    name: String,
    field_type: String,
}

type CompiledEnum {
    name: String,
    variants: List<String>,
}

type CompiledState {
    name: String,
    fields: List<CompiledField>,
    invariants: List<String>,
}

type CompiledAction {
    name: String,
    parameters: List<CompiledField>,
    return_type: Option<String>,
    preconditions: List<String>,
    postconditions: List<String>,
}

type CompiledScenario {
    description: String,
    given: List<String>,
    when_action: List<String>,
    then_assertions: List<String>,
}

type CompiledProperty {
    description: String,
    temporal_op: Option<String>,
    expression: String,
}

enum DiagramType {
    Erd,
    State,
    Sequence,
}

// ============================================================================
// Scenarios: Usage Examples
// ============================================================================

scenario "Parse a simple type definition" {
    given {
        source = "type User { id: Int, name: String }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().types.len() == 1
    }
}

scenario "Parse a state with invariant" {
    given {
        // Note: Source contains a state with invariant
        source = "state System { users: Set<User> }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().states.len() == 1
    }
}

scenario "Parse dotted module name" {
    given {
        source = "module abc.def.ghi\n\ntype User { id: Int }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().module is Some
        result.unwrap().module.unwrap().path.segments.len() == 3
    }
}

scenario "Generate documentation from compiled spec" {
    given {
        spec = CompiledSpec {
            name: "test",
            structs: [],
            enums: [],
            states: [],
            actions: [],
            scenarios: [],
            properties: [],
        }
    }
    when {
        markdown = generate_markdown(spec)
    }
    then {
        markdown.len() > 0
    }
}

scenario "Cross-file type import" {
    given {
        // File 1: defines shared types
        types_file = "module types\n\ntype UserId { value: Int }\ntype Email { address: String }"
        // File 2: imports and uses the types
        users_file = "module users\n\nuse types::{UserId, Email}\n\ntype User { id: UserId, email: Email }"
    }
    when {
        types_spec = parse(types_file)
        users_spec = parse(users_file)
        registry = build_module_registry([types_spec.unwrap(), users_spec.unwrap()])
    }
    then {
        // UserId and Email should be available in the users module
        registry.is_type_available("users", "UserId")
        registry.is_type_available("users", "Email")
        registry.is_type_available("users", "User")
    }
}

scenario "Import with alias" {
    given {
        types_file = "module types\n\ntype Identifier { value: String }"
        users_file = "module users\n\nuse types::{Identifier as Id}\n\ntype User { id: Id }"
    }
    when {
        types_spec = parse(types_file)
        users_spec = parse(users_file)
        registry = build_module_registry([types_spec.unwrap(), users_spec.unwrap()])
    }
    then {
        // Id should be available (aliased from Identifier)
        registry.is_type_available("users", "Id")
    }
}

// ============================================================================
// Properties: System Guarantees
// ============================================================================

property "Parsing is deterministic" {
    always {
        forall source: String =>
            parse(source) == parse(source)
    }
}

property "Valid specs produce no errors" {
    always {
        forall spec: Specification where analyze(spec).len() == 0 =>
            compile(spec) is Ok
    }
}

property "Type names are unique within a specification" {
    always {
        forall spec: Specification, t1, t2 in spec.types where t1 != t2 =>
            t1.name != t2.name
    }
}

property "Imported types must exist in source module" {
    always {
        forall registry: ModuleRegistry, import in registry.current_module_info().imports =>
            forall item in import.items =>
                registry.get_module(import.source_module).types.contains(item.original_name)
    }
}

// ============================================================================
// Error Reporting
// ============================================================================

type SourceLocation {
    line: Int,
    column: Int,
}

type ErrorContext {
    path: String,
    source: String,
    location: SourceLocation,
}

enum ErrorKind {
    Parse,
    Semantic,
    Io,
}

type CompilerError {
    kind: ErrorKind,
    message: String,
    context: Option<ErrorContext>,
}

action compute_location(source: String, byte_offset: Int) -> SourceLocation
    requires {
        byte_offset >= 0 and byte_offset <= source.len()
    }
    ensures {
        result.line >= 1 and result.column >= 1
    }

action format_error(error: CompilerError) -> String
    ensures {
        // Error messages must include location when context is available
        match error.context {
            Some(ctx) => result.contains(ctx.location.line.to_string()),
            None => true,
        }
    }

scenario "Parse match with block body" {
    given {
        source = "state Test { x: Int, invariant { match x { 0 => { false }, _ => { x > 0 } } } }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
    }
}

scenario "Parse error includes line number" {
    given {
        source = "type User {\n    id: Int,\n    invalid syntax\n}"
    }
    when {
        result = parse(source)
    }
    then {
        result is Err
        // Error message should contain line number
    }
}

scenario "Parse scenario with trailing commas in bindings" {
    given {
        // Scenario bindings support optional trailing commas after values
        // e.g., status = Status.Active, (comma is optional but allowed)
        source = "scenario with trailing commas"
    }
    when {
        result = parse(source)
    }
    then {
        // Parser should accept trailing commas in given/when/then bindings
        result is Ok
    }
}

property "All errors with spans have valid line numbers" {
    always {
        forall error: CompilerError where error.context is Some =>
            error.context.unwrap().location.line >= 1
    }
}

// ============================================================================
// Lexer and Tokens
// ============================================================================

// Token produced by the lexer
enum Token {
    // ========== Keywords ==========
    Use,            // use
    Type,           // type
    Enum,           // enum
    Relation,       // relation
    State,          // state
    Action,         // action
    Invariant,      // invariant
    Requires,       // requires
    Ensures,        // ensures
    Scenario,       // scenario
    Alt,            // alt
    Quality,        // quality
    Property,       // property
    Always,         // always
    Eventually,     // eventually
    Forall,         // forall
    Exists,         // exists
    In,             // in
    Where,          // where
    Match,          // match
    If,             // if
    Else,           // else
    Let,            // let
    Fn,             // fn
    Return,         // return
    SelfKw,         // self

    // ========== Logical operators ==========
    And,            // and
    Or,             // or
    Not,            // not
    Implies,        // implies

    // ========== Boolean literals ==========
    True,           // true
    False,          // false

    // ========== Relation constraints ==========
    Symmetric,      // symmetric
    Reflexive,      // reflexive
    Irreflexive,    // irreflexive
    Transitive,     // transitive
    Antisymmetric,  // antisymmetric

    // ========== Type keywords ==========
    IsKw,           // is
    OkKw,           // Ok
    ErrKw,          // Err
    SomeKw,         // Some
    NoneKw,         // None

    // ========== Punctuation ==========
    LBrace,         // {
    RBrace,         // }
    LParen,         // (
    RParen,         // )
    LBracket,       // [
    RBracket,       // ]
    LAngle,         // <
    RAngle,         // >
    Comma,          // ,
    Colon,          // :
    ColonColon,     // ::
    Semicolon,      // ;
    Dot,            // .
    DotDot,         // ..
    Arrow,          // ->
    FatArrow,       // =>
    Pipe,           // |
    Underscore,     // _
    Prime,          // '
    At,             // @

    // ========== Operators ==========
    Eq,             // =
    EqEq,           // ==
    NotEq,          // !=
    LtEq,           // <=
    GtEq,           // >=
    Plus,           // +
    Minus,          // -
    Star,           // *
    Slash,          // /
    Percent,        // %
    AndAnd,         // &&
    OrOr,           // ||
    Bang,           // !

    // ========== Literals ==========
    Integer,        // 42, 0, 100 (with i64 value)
    String,         // "hello" (with SmolStr value)
    Ident,          // foo, User, _private (with SmolStr value)
}

// Lexed token with position information
type LexedToken {
    token: Token,
    span: Span,
}

// ============================================================================
// Semantic Analysis
// ============================================================================

// Semantic error types produced during analysis
enum SemanticErrorKind {
    // Reference to undefined name: unknown type, variable, etc.
    Undefined,
    // Duplicate definition: type name already exists
    Duplicate,
    // Type mismatch: expected Int, found String
    TypeMismatch,
    // Invalid type: Map requires 2 type arguments
    InvalidType,
    // Arity mismatch: function expects 2 args, got 3
    ArityMismatch,
    // Invalid operation: cannot add Int and String
    InvalidOperation,
    // Cyclic dependency: type A references type B which references type A
    CyclicDependency,
    // Missing required element: state must have at least one field
    Missing,
    // Invalid pattern: cannot use struct pattern here
    InvalidPattern,
    // Non-exhaustive match: missing case for variant X
    NonExhaustive,
    // Duplicate ID attribute: @id("REQ-001") used twice
    DuplicateId,
    // Unknown reference in attribute: @relates_to("UNKNOWN-001")
    UnknownReference,
}

type SemanticError {
    kind: SemanticErrorKind,
    message: String,
    span: Span,
    related_span: Option<Span>,
}

// Import validation errors
enum ImportErrorKind {
    // Module not found: use nonexistent::module
    ModuleNotFound,
    // Item not found in module: use types::{NonexistentType}
    ItemNotFound,
}

type ImportError {
    kind: ImportErrorKind,
    module_name: String,
    item_name: Option<String>,
    span: Span,
}

// Resolved type information
enum ResolvedType {
    // Primitive types
    Int,
    String,
    Bool,
    // Collection types
    Set,
    List,
    Map,
    Option,
    Result,
    // User-defined types
    UserDefined,
    // Enum type
    Enum,
    // Type alias
    Alias,
    // Function type
    Function,
    // Tuple type
    Tuple,
    // Unit type
    Unit,
    // Unknown (for error recovery)
    Unknown,
}

// Type registry for semantic analysis
type TypeRegistry {
    types: Map<String, ResolvedType>,
    enums: Map<String, EnumInfo>,
    aliases: Map<String, AliasInfo>,
}

type EnumInfo {
    name: String,
    variants: List<String>,
}

type AliasInfo {
    name: String,
    target: ResolvedType,
}

// Symbol table for name resolution
type SymbolTable {
    scopes: List<Scope>,
}

type Scope {
    symbols: Map<String, SymbolInfo>,
    parent: Option<Int>,
}

type SymbolInfo {
    name: String,
    kind: SymbolKind,
    resolved_type: ResolvedType,
    span: Span,
}

enum SymbolKind {
    Variable,
    Parameter,
    TypeName,
    EnumName,
    EnumVariant,
    StateName,
    ActionName,
    FieldName,
}

// ============================================================================
// Quality Requirements (NFRs)
// ============================================================================

// Quality/Non-Functional Requirement definition
type Quality {
    attributes: List<Attribute>,
    category: QualityCategory,
    description: String,
    metric: Ident,
    scale: Option<Scale>,
    target: QualityTarget,
    constraint: Option<Constraint>,
    applies_to: Option<AppliesTo>,
    measurement: Option<MeasurementPeriod>,
    under_load: Option<LoadConditions>,
    verified_by: List<VerificationMethod>,
    properties: List<QualityProperty>,
    span: Span,
}

// Statistical scale for measurements
enum Scale {
    Mean,
    Median,
    P50,
    P90,
    P95,
    P99,
    P999,
    Max,
    Min,
}

// Whether a quality target is a hard constraint or soft target
enum Constraint {
    Hard,
    Soft,
}

// Measurement period for quality metrics
enum MeasurementPeriod {
    PerRequest,
    PerSecond,
    PerMinute,
    Hourly,
    Daily,
    Weekly,
    Monthly,
}

// Load conditions under which the quality is measured
type LoadConditions {
    concurrent_users: Option<Int>,
    concurrent_connections: Option<Int>,
    requests_per_second: Option<Int>,
    payload_size: Option<SizeValue>,
    duration: Option<DurationValue>,
    span: Span,
}

// Size value with unit
type SizeValue {
    value: Int,
    unit: SizeUnit,
}

// Duration value with unit
type DurationValue {
    value: Int,
    unit: DurationUnit,
}

// Verification method for a quality requirement
type VerificationMethod {
    kind: VerificationKind,
    name: String,
    span: Span,
}

// Kind of verification method
enum VerificationKind {
    Test,
    Monitor,
    Benchmark,
    Audit,
}

// Reference to what a quality applies to
type AppliesTo {
    kind: AppliesToKind,
    name: Ident,
    span: Span,
}

// Kind of applies_to target
enum AppliesToKind {
    Action,
    Type,
    State,
}

// Categories of quality requirements
enum QualityCategory {
    Performance,
    Reliability,
    Security,
    Usability,
    Scalability,
    Maintainability,
}

// Target specification for a quality requirement
type QualityTarget {
    op: QualityOp,
    value: QualityValue,
    span: Span,
}

// Comparison operator for quality targets
enum QualityOp {
    Lt,     // <
    LtEq,   // <=
    Gt,     // >
    GtEq,   // >=
    Eq,     // ==
}

// Value types for quality targets
enum QualityValue {
    // Integer value: 100
    Int,
    // Percentage: 99.9%
    Percentage,
    // Duration: 100ms, 5s, 1m, 2h
    Duration,
    // Size: 10KB, 5MB, 1GB
    Size,
    // Rate: 1000/s, 60/m, 100/h
    Rate,
    // Expression: custom expression
    Expr,
}

// Duration units for quality values
enum DurationUnit {
    Ms,     // milliseconds
    S,      // seconds
    M,      // minutes
    H,      // hours
}

// Size units for quality values
enum SizeUnit {
    Kb,     // kilobytes
    Mb,     // megabytes
    Gb,     // gigabytes
    Tb,     // terabytes
}

// Rate units for quality values
enum RateUnit {
    PerSecond,
    PerMinute,
    PerHour,
}

// Additional properties in quality blocks
type QualityProperty {
    name: Ident,
    value: QualityPropertyValue,
    span: Span,
}

enum QualityPropertyValue {
    // Identifier value: metric_name
    Ident,
    // Target specification
    Target,
    // Applies to clause
    AppliesTo,
}

// ============================================================================
// Quality Examples
// ============================================================================

@id("NFR-001")
quality performance "Parse time for typical specs" {
    metric: latency,
    target: < 100ms,
}

@id("NFR-002")
quality reliability "Parser handles malformed input gracefully" {
    metric: error_handling,
    target: == 100%,
}

@id("NFR-003")
quality maintainability "Code coverage" {
    metric: test_coverage,
    target: >= 80%,
}
