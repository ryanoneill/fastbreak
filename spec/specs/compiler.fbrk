// Fastbreak Compiler Specification
// Compiler pipeline, lexer, semantic analysis, and quality requirements
module fastbreak.compiler

use fastbreak::{
    Specification,
    Span,
    Ident,
    Attribute,
    ModuleRegistry,
    Quality,
    QualityCategory,
    QualityTarget,
    QualityOp,
    QualityValue,
    Scale,
    Constraint,
    AppliesTo,
    AppliesToKind,
    MeasurementPeriod,
    LoadConditions,
    VerificationMethod,
    VerificationKind,
    QualityProperty,
    QualityPropertyValue,
    DurationUnit,
    SizeUnit,
    RateUnit,
}

// ============================================================================
// State: Compiler Pipeline
// ============================================================================

state CompilerPipeline {
    source_files: Set<String>,
    parsed_specs: Map<String, Specification>,
    errors: List<String>,

    invariant "All parsed specs have source files" {
        forall path in parsed_specs.keys() =>
            path in source_files
    }
}

// ============================================================================
// Actions: Compiler Operations
// ============================================================================

action parse(source: String) -> Result<Specification, String>
    ensures {
        match result {
            Ok(spec) => spec.types.len() >= 0,
            Err(msg) => msg.len() > 0,
        }
    }

action analyze(spec: Specification) -> List<String>
    ensures {
        // Returns list of semantic errors (empty if valid)
        result.len() >= 0
    }

action compile(spec: Specification) -> CompiledSpec
    requires {
        // Specification must pass semantic analysis
        analyze(spec).len() == 0
    }

action generate_markdown(spec: CompiledSpec) -> String
    ensures {
        result.len() > 0
    }

action generate_diagram(spec: CompiledSpec, diagram_type: DiagramType) -> String
    ensures {
        result.len() > 0
    }

action build_module_registry(specs: List<Specification>) -> ModuleRegistry
    ensures {
        // All modules from input specs are registered
        forall spec in specs where spec.module is Some =>
            result.modules.contains_key(spec.module.unwrap().path)
    }

action resolve_imports(registry: ModuleRegistry, module_name: String) -> List<String>
    requires {
        registry.modules.contains_key(module_name)
    }
    ensures {
        // Returns list of unresolved import errors (empty if all resolved)
        result.len() >= 0
    }

// Action contracts can reference state fields from the enclosing state.
// In requires clauses: state fields represent the current state
// In ensures clauses: state fields represent current state, state' represents next state
action load_source(path: String) -> Result<String, String>
    requires {
        // State field access in requires - references current state
        not (path in source_files)
    }
    ensures {
        match result {
            Ok(content) => path in source_files' and errors' == errors,
            Err(msg) => source_files' == source_files,
        }
    }

action clear_errors() -> Int
    requires {
        errors.len() > 0
    }
    ensures {
        result == old(errors.len()) and errors'.len() == 0
    }

// ============================================================================
// Supporting Types for Actions
// ============================================================================

type CompiledSpec {
    name: String,
    structs: List<CompiledStruct>,
    enums: List<CompiledEnum>,
    states: List<CompiledState>,
    actions: List<CompiledAction>,
    scenarios: List<CompiledScenario>,
    properties: List<CompiledProperty>,
}

type CompiledStruct {
    name: String,
    fields: List<CompiledField>,
}

type CompiledField {
    name: String,
    field_type: String,
}

type CompiledEnum {
    name: String,
    variants: List<String>,
}

type CompiledState {
    name: String,
    fields: List<CompiledField>,
    invariants: List<String>,
}

type CompiledAction {
    name: String,
    parameters: List<CompiledField>,
    return_type: Option<String>,
    preconditions: List<String>,
    postconditions: List<String>,
}

type CompiledScenario {
    description: String,
    given: List<String>,
    when_action: List<String>,
    then_assertions: List<String>,
}

type CompiledProperty {
    description: String,
    temporal_op: Option<String>,
    expression: String,
}

enum DiagramType {
    Erd,
    State,
    Sequence,
}

// ============================================================================
// Scenarios: Usage Examples
// ============================================================================

scenario "Parse a simple type definition" {
    given {
        source = "type User { id: Int, name: String }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().types.len() == 1
    }
}

scenario "Parse a state with invariant" {
    given {
        // Note: Source contains a state with invariant
        source = "state System { users: Set<User> }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().states.len() == 1
    }
}

scenario "Parse dotted module name" {
    given {
        source = "module abc.def.ghi\n\ntype User { id: Int }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().module is Some
        result.unwrap().module.unwrap().path.segments.len() == 3
    }
}

scenario "Generate documentation from compiled spec" {
    given {
        spec = CompiledSpec {
            name: "test",
            structs: [],
            enums: [],
            states: [],
            actions: [],
            scenarios: [],
            properties: [],
        }
    }
    when {
        markdown = generate_markdown(spec)
    }
    then {
        markdown.len() > 0
    }
}

scenario "Cross-file type import" {
    given {
        // File 1: defines shared types
        types_file = "module types\n\ntype UserId { value: Int }\ntype Email { address: String }"
        // File 2: imports and uses the types
        users_file = "module users\n\nuse types::{UserId, Email}\n\ntype User { id: UserId, email: Email }"
    }
    when {
        types_spec = parse(types_file)
        users_spec = parse(users_file)
        registry = build_module_registry([types_spec.unwrap(), users_spec.unwrap()])
    }
    then {
        // Both modules should be registered
        "types" in registry.modules
        "users" in registry.modules
    }
}

scenario "Import with alias" {
    given {
        types_file = "module types\n\ntype Identifier { value: String }"
        users_file = "module users\n\nuse types::{Identifier as Id}\n\ntype User { id: Id }"
    }
    when {
        types_spec = parse(types_file)
        users_spec = parse(users_file)
        registry = build_module_registry([types_spec.unwrap(), users_spec.unwrap()])
    }
    then {
        // Both modules should be registered
        "types" in registry.modules
        "users" in registry.modules
    }
}

scenario "Type alias forward reference" {
    given {
        // Type alias defined before struct that uses it
        source = "type UserId = Int where self > 0\n\ntype User { id: UserId, name: String }"
    }
    when {
        spec = parse(source)
        errors = analyze(spec.unwrap())
    }
    then {
        // Type alias should be resolvable when used in later type
        errors.len() == 0
    }
}

scenario "Dotted binding names in scenarios" {
    given {
        // Bindings can use dotted paths to set state fields
        // Note: Actual test uses escaped quotes, simplified here
        source = "type Catalog { entries: Set<String> }"
    }
    when {
        result = parse(source)
    }
    then {
        // Parsing should succeed - actual dotted binding test is in Rust tests
        result is Ok
    }
}

// ============================================================================
// Properties: System Guarantees
// ============================================================================
// TODO: Properties temporarily commented out due to semantic analyzer limitations

// property "Parsing is deterministic" {
//     always {
//         forall source: String =>
//             parse(source) == parse(source)
//     }
// }
//
// property "Valid specs produce no errors" {
//     always {
//         forall spec: Specification where analyze(spec).len() == 0 =>
//             compile(spec) is Ok
//     }
// }
//
// property "Type names are unique within a specification" {
//     always {
//         forall spec: Specification, t1, t2 in spec.types where t1 != t2 =>
//             t1.name != t2.name
//     }
// }
//
// property "Imported types must exist in source module" {
//     always {
//         forall registry: ModuleRegistry, import in registry.current_module_info().imports =>
//             forall item in import.items =>
//                 registry.get_module(import.source_module).types.contains(item.original_name)
//     }
// }

// ============================================================================
// Error Reporting
// ============================================================================

type SourceLocation {
    line: Int,
    column: Int,
}

type ErrorContext {
    path: String,
    source: String,
    location: SourceLocation,
}

enum ErrorKind {
    Parse,
    Semantic,
    Io,
}

type CompilerError {
    kind: ErrorKind,
    message: String,
    context: Option<ErrorContext>,
}

action compute_location(source: String, byte_offset: Int) -> SourceLocation
    requires {
        byte_offset >= 0 and byte_offset <= source.len()
    }
    ensures {
        result.line >= 1 and result.column >= 1
    }

// TODO: Commenting out due to semantic analyzer limitations with method calls
// action format_error(error: CompilerError) -> String
//     ensures {
//         // Error messages must include location when context is available
//         match error.context {
//             Some(ctx) => result.contains(ctx.location.line.to_string()),
//             None => true,
//         }
//     }

scenario "Parse match with block body" {
    given {
        source = "state Test { x: Int, invariant { match x { 0 => { false }, _ => { x > 0 } } } }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
    }
}

scenario "Parse error includes line number" {
    given {
        source = "type User {\n    id: Int,\n    invalid syntax\n}"
    }
    when {
        result = parse(source)
    }
    then {
        result is Err
        // Error message should contain line number
    }
}

// TODO: Commenting out - scenario name doesn't parse correctly
// scenario "Parse scenario with trailing commas in bindings" {
//     given {
//         // Scenario bindings support optional trailing commas after values
//         // e.g., status = Status.Active, (comma is optional but allowed)
//         source = "scenario with trailing commas"
//     }
//     when {
//         result = parse(source)
//     }
//     then {
//         // Parser should accept trailing commas in given/when/then bindings
//         result is Ok
//     }
// }

scenario "Analyze action contracts with state field access" {
    given {
        // State fields should be accessible in action contracts
        source = "state Counter { count: Int } action increment(n: Int) requires { count >= 0 } ensures { count' == count + n }"
    }
    when {
        spec = parse(source)
        errors = analyze(spec.unwrap())
    }
    then {
        // State fields (count) should be resolvable in requires/ensures
        errors.len() == 0
    }
}

scenario "Analyze action calls in invariants" {
    given {
        // Actions can be called in invariant expressions as helper/predicate functions
        source = "action is_valid(s: String) -> Bool\n\nstate Registry { paths: Set<String>, invariant { forall p in paths => is_valid(p) } }"
    }
    when {
        spec = parse(source)
        errors = analyze(spec.unwrap())
    }
    then {
        // Action calls in invariants should resolve successfully
        errors.len() == 0
    }
}

property "All errors with spans have valid line numbers" {
    always {
        forall error: CompilerError where error.context is Some =>
            error.context.unwrap().location.line >= 1
    }
}

// ============================================================================
// Lexer and Tokens
// ============================================================================

// Token produced by the lexer
enum Token {
    // ========== Keywords ==========
    Use,            // use
    Type,           // type
    Enum,           // enum
    Relation,       // relation
    State,          // state
    Action,         // action
    Invariant,      // invariant
    Requires,       // requires
    Ensures,        // ensures
    Scenario,       // scenario
    Alt,            // alt
    Quality,        // quality
    Property,       // property
    Always,         // always
    Eventually,     // eventually
    Forall,         // forall
    Exists,         // exists
    In,             // in
    Where,          // where
    Match,          // match
    If,             // if
    Else,           // else
    Let,            // let
    Fn,             // fn
    Return,         // return
    SelfKw,         // self

    // ========== Logical operators ==========
    And,            // and
    Or,             // or
    Not,            // not
    Implies,        // implies

    // ========== Boolean literals ==========
    True,           // true
    False,          // false

    // ========== Relation constraints ==========
    Symmetric,      // symmetric
    Reflexive,      // reflexive
    Irreflexive,    // irreflexive
    Transitive,     // transitive
    Antisymmetric,  // antisymmetric

    // ========== Type keywords ==========
    // Note: Rust code uses Is, Ok, Err, Some, None but these are reserved
    // keywords in fastbreak, so we use the Kw suffix here
    IsKw,           // is (Rust: Is)
    OkKw,           // Ok (Rust: Ok)
    ErrKw,          // Err (Rust: Err)
    SomeKw,         // Some (Rust: Some)
    NoneKw,         // None (Rust: None)

    // ========== Punctuation ==========
    LBrace,         // {
    RBrace,         // }
    LParen,         // (
    RParen,         // )
    LBracket,       // [
    RBracket,       // ]
    LAngle,         // <
    RAngle,         // >
    Comma,          // ,
    Colon,          // :
    ColonColon,     // ::
    Semicolon,      // ;
    Dot,            // .
    DotDot,         // ..
    Arrow,          // ->
    FatArrow,       // =>
    Pipe,           // |
    Underscore,     // _
    Prime,          // '
    At,             // @

    // ========== Operators ==========
    Eq,             // =
    EqEq,           // ==
    NotEq,          // !=
    LtEq,           // <=
    GtEq,           // >=
    Plus,           // +
    Minus,          // -
    Star,           // *
    Slash,          // /
    Percent,        // %
    AndAnd,         // &&
    OrOr,           // ||
    Bang,           // !

    // ========== Literals ==========
    Integer,        // 42, 0, 100 (with i64 value)
    Float,          // 3.14, 99.99 (with f64 value)
    String,         // "hello" (with SmolStr value)
    Ident,          // foo, User, _private (with SmolStr value)
}

// Lexed token with position information
type LexedToken {
    token: Token,
    span: Span,
}

// ============================================================================
// Semantic Analysis
// ============================================================================

// Semantic error types produced during analysis
enum SemanticErrorKind {
    // Reference to undefined name: unknown type, variable, etc.
    Undefined,
    // Duplicate definition: type name already exists
    Duplicate,
    // Type mismatch: expected Int, found String
    TypeMismatch,
    // Invalid type: Map requires 2 type arguments
    InvalidType,
    // Arity mismatch: function expects 2 args, got 3
    ArityMismatch,
    // Invalid operation: cannot add Int and String
    InvalidOperation,
    // Cyclic dependency: type A references type B which references type A
    CyclicDependency,
    // Missing required element: state must have at least one field
    Missing,
    // Invalid pattern: cannot use struct pattern here
    InvalidPattern,
    // Non-exhaustive match: missing case for variant X
    NonExhaustive,
    // Duplicate ID attribute: @id("REQ-001") used twice
    DuplicateId,
    // Unknown reference in attribute: @relates_to("UNKNOWN-001")
    UnknownReference,
}

type SemanticError {
    kind: SemanticErrorKind,
    message: String,
    span: Span,
    related_span: Option<Span>,
}

// Import validation errors
enum ImportErrorKind {
    // Module not found: use nonexistent::module
    ModuleNotFound,
    // Item not found in module: use types::{NonexistentType}
    ItemNotFound,
}

type ImportError {
    kind: ImportErrorKind,
    module_name: String,
    item_name: Option<String>,
    span: Span,
}

// Resolved semantic type (maps to src/semantic/types.rs Type enum)
enum ResolvedType {
    // Primitive types
    Int,
    Float,
    String,
    Bool,
    Unit,
    // User-defined types
    Struct,         // Struct(TypeId)
    Enum,           // Enum(TypeId)
    // Collection types
    Set,            // Set(Arc<Type>)
    List,           // List(Arc<Type>)
    Map,            // Map(Arc<Type>, Arc<Type>)
    Option,         // Option(Arc<Type>)
    Result,         // Result(Arc<Type>, Arc<Type>)
    // Compound types
    Tuple,          // Tuple(Vec<Type>)
    Function,       // Function { params, ret }
    // Type variables and inference
    Var,            // Type variable for generics
    Unknown,        // Used during type inference
    Error,          // Used when type checking fails
}

// Type registry for semantic analysis
type TypeRegistry {
    types: Map<String, ResolvedType>,
    enums: Map<String, EnumInfo>,
    aliases: Map<String, AliasInfo>,
}

type EnumInfo {
    name: String,
    variants: List<String>,
}

type AliasInfo {
    name: String,
    target: ResolvedType,
}

// Symbol table for name resolution
type SymbolTable {
    scopes: List<Scope>,
}

type Scope {
    symbols: Map<String, SymbolInfo>,
    parent: Option<Int>,
}

type SymbolInfo {
    name: String,
    kind: SymbolKind,
    resolved_type: ResolvedType,
    span: Span,
}

enum SymbolKind {
    Variable,
    Parameter,
    TypeName,
    EnumName,
    EnumVariant,
    StateName,
    ActionName,
    FieldName,
}

// ============================================================================
// Quality Examples
// ============================================================================
// Quality types are imported from fastbreak module (main.fbrk)

@id("NFR-001")
quality performance "Parse time for typical specs" {
    metric: latency,
    target: < 100ms,
}

@id("NFR-002")
quality reliability "Parser handles malformed input gracefully" {
    metric: error_handling,
    target: == 100%,
}

@id("NFR-003")
quality maintainability "Code coverage" {
    metric: test_coverage,
    target: >= 80%,
}
