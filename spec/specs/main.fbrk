// Fastbreak Self-Specification
// A formal specification of Fastbreak's own domain model
module fastbreak

// ============================================================================
// Core Types
// ============================================================================

// An identifier with source location
type Ident {
    name: String,
    span: Span,
}

type Span {
    start: Int,
    end: Int,
}

// Note: Conceptual enum for documentation - subsumed by BuiltInType in implementation.
// Float is a semantic Type but not a BuiltInType (cannot write `x: Float` in specs).
enum PrimitiveType {
    Int,
    String,
    Bool,
    Float,
}

// ============================================================================
// Attributes
// ============================================================================

// Attribute on definitions: @id("REQ-001"), @deprecated, @since("1.0")
type Attribute {
    name: Ident,
    args: List<AttributeArg>,
    span: Span,
}

// Argument to an attribute (enum with associated data)
// Rust: pub enum AttributeArg { String(SmolStr, Span), Ident(Ident), Int(i64, Span) }
enum AttributeArg {
    // String argument: @id("REQ-001") - carries (String, Span)
    String,
    // Identifier argument: @category(security) - carries Ident
    Ident,
    // Integer argument: @priority(1) - carries (Int, Span)
    Int,
}

// ============================================================================
// Type System
// ============================================================================

// Built-in types provided by the language
enum BuiltInType {
    Int,
    String,
    Bool,
    Set,
    Map,
    List,
    Option,
    Result,
}

type TypeRef {
    kind: TypeRefKind,
    span: Span,
}

// Kind of type reference
enum TypeRefKind {
    // A simple type name or path: User, common::types::Email
    Named,
    // A built-in type: Int, String, Bool
    BuiltIn,
    // A generic type with arguments: Set<User>, Map<String, Int>
    Generic,
    // A function type: (A, B) -> C
    Function,
    // A tuple type: (A, B)
    Tuple,
    // Unit type: ()
    Unit,
}

type GenericArg {
    ty: TypeRef,
}

type Field {
    name: Ident,
    ty: TypeRef,
    span: Span,
}

type TypeDef {
    attributes: List<Attribute>,
    name: Ident,
    type_params: List<Ident>,
    fields: List<Field>,
    refinement: Option<Expression>,
    span: Span,
}

type EnumVariant {
    name: Ident,
    fields: List<Field>,
    span: Span,
}

type EnumDef {
    attributes: List<Attribute>,
    name: Ident,
    type_params: List<Ident>,
    variants: List<EnumVariant>,
    span: Span,
}

type TypeAlias {
    attributes: List<Attribute>,
    name: Ident,
    type_params: List<Ident>,
    base: TypeRef,
    refinement: Option<Expression>,
    span: Span,
}

// ============================================================================
// Relations
// ============================================================================

// Relation definition: relation friends: User -> Set<User> { symmetric }
type Relation {
    attributes: List<Attribute>,
    name: Ident,
    source: TypeRef,
    target: TypeRef,
    constraints: List<RelationConstraint>,
    span: Span,
}

// Constraints on relations (Alloy-inspired)
enum RelationConstraint {
    // The relation is symmetric: a R b implies b R a
    Symmetric,
    // The relation is reflexive: a R a for all a
    Reflexive,
    // The relation is irreflexive: not (a R a) for all a
    Irreflexive,
    // The relation is transitive: a R b and b R c implies a R c
    Transitive,
    // The relation is antisymmetric: a R b and b R a implies a = b
    Antisymmetric,
}

// ============================================================================
// State and Actions
// ============================================================================

type StateField {
    name: Ident,
    ty: TypeRef,
    init: Option<Expression>,
    span: Span,
}

// State invariant - a boolean expression that must always hold.
// Invariant expressions can reference:
// - State fields defined in the enclosing state
// - Actions defined in the same specification (for helper/predicate functions)
// - Global types and enums
type Invariant {
    attributes: List<Attribute>,
    description: Option<String>,
    expr: Expression,
    span: Span,
}

type StateBlock {
    attributes: List<Attribute>,
    name: Ident,
    fields: List<StateField>,
    invariants: List<Invariant>,
    span: Span,
}

type ActionParam {
    name: Ident,
    ty: TypeRef,
    span: Span,
}

enum ContractKind {
    Requires,
    Ensures,
}

type Contract {
    kind: ContractKind,
    expr: Expression,
    span: Span,
}

type Action {
    attributes: List<Attribute>,
    name: Ident,
    params: List<ActionParam>,
    return_type: Option<TypeRef>,
    contracts: List<Contract>,
    body: Option<Expression>,
    span: Span,
}

// ============================================================================
// Scenarios
// ============================================================================

// Binding supports dotted names for state field access, e.g., catalog.entries = {}
type Binding {
    name: Path,
    value: Expression,
    span: Span,
}

type Assertion {
    expr: Expression,
    description: Option<String>,
    span: Span,
}

type GivenClause {
    bindings: List<Binding>,
    span: Span,
}

type WhenClause {
    bindings: List<Binding>,
    span: Span,
}

type ThenClause {
    assertions: List<Assertion>,
    span: Span,
}

type Alternative {
    attributes: List<Attribute>,
    name: String,
    condition: Option<Expression>,
    given: Option<GivenClause>,
    when: Option<WhenClause>,
    then: ThenClause,
    span: Span,
}

type Scenario {
    attributes: List<Attribute>,
    description: String,
    given: GivenClause,
    when: WhenClause,
    then: ThenClause,
    alternatives: List<Alternative>,
    span: Span,
}

// ============================================================================
// Properties
// ============================================================================

enum TemporalOp {
    Always,
    Eventually,
}

type Property {
    attributes: List<Attribute>,
    description: String,
    temporal_op: Option<TemporalOp>,
    expr: Expression,
    span: Span,
}

// ============================================================================
// Expressions
// ============================================================================

// Note: Rust implementation uses shortened names: Expr, ExprKind
type Expression {
    kind: ExpressionKind,
    span: Span,
}

// Full enumeration of expression kinds
// Note: Rust implementation uses ExprKind
enum ExpressionKind {
    // Literals: integers, strings, booleans, unit
    Literal,
    // Variable or path reference: x, user.email
    Var,
    // Binary operation: left op right
    Binary,
    // Unary operation: op expr
    Unary,
    // Function call: f(args)
    Call,
    // Method call with receiver: users.map(u => u.id)
    MethodCall,
    // Field access: expr.field
    Field,
    // Index access: expr[index]
    Index,
    // Match expression: match expr { arms }
    Match,
    // If expression: if cond { then } else { else }
    If,
    // Block expression: { stmts; expr }
    Block,
    // List literal: [a, b, c]
    List,
    // Set literal: {a, b, c}
    Set,
    // Map literal: {k1: v1, k2: v2}
    Map,
    // Struct literal: Type { field: value }
    Struct,
    // Tuple literal: (a, b, c)
    Tuple,
    // Lambda: |params| body or x => body
    Lambda,
    // Let binding: let x = expr in body
    Let,
    // Universal quantifier: forall x in xs => pred(x)
    Forall,
    // Existential quantifier: exists x in xs => pred(x)
    Exists,
    // Implication: a implies b
    Implies,
    // Range: start..end
    Range,
    // Type/pattern check: expr is Type or expr is Ok(value)
    Is,
    // Old value in postcondition: old(expr)
    Old,
    // Next state value: expr'
    Prime,
    // Result value in postconditions
    Result,
    // Self reference in refinement predicates
    SelfRef,
}

// ============================================================================
// Operators
// ============================================================================

enum BinaryOp {
    // Arithmetic operators
    Add,        // +
    Sub,        // -
    Mul,        // *
    Div,        // /
    Mod,        // %
    // Comparison operators
    Eq,         // ==
    NotEq,      // !=
    Lt,         // <
    LtEq,       // <=
    Gt,         // >
    GtEq,       // >=
    // Logical operators
    And,        // and
    Or,         // or
    // Note: Implies is handled as ExpressionKind::Implies, not a binary operator
    // Set/collection operators
    In,         // in
    Union,      // union
    Intersect,  // intersect
    Difference, // difference / setminus
}

enum UnaryOp {
    // Logical negation: not expr
    Not,
    // Arithmetic negation: -expr
    Neg,
}

// ============================================================================
// Literals
// ============================================================================

// Note: In Rust implementation, variants carry associated data:
// Int(i64), Float(f64), String(SmolStr), Bool(bool), Unit
enum Literal {
    // Integer literal: 42, -1
    Int,
    // Float literal: 3.14, 99.99
    Float,
    // String literal: "hello" - Rust: String(SmolStr)
    String,
    // Boolean literal: true, false
    Bool,
    // Unit/empty tuple: ()
    Unit,
}

// Note: The following literal types are conceptual - in Rust implementation,
// values are embedded directly in Literal enum variants: Int(i64), Float(f64), etc.

type IntLiteral {
    value: Int,
}

// Note: FloatLiteral uses f64 internally in the implementation
// Float is not yet a built-in type reference (cannot write x: Float)
// but Float literals create Type::Float in semantic analysis
type FloatLiteral {
    // Rust: f64 - Float is not a BuiltInType, only a semantic Type
    value: Int,
}

type StringLiteral {
    value: String,
}

type BoolLiteral {
    value: Bool,
}

// ============================================================================
// Quantifiers
// ============================================================================

// Note: Conceptual type for documentation - not implemented as separate enum.
// In Rust, forall/exists are ExprKind variants directly.
enum QuantifierKind {
    // Universal: forall x in xs => predicate
    ForAll,
    // Existential: exists x in xs where predicate
    Exists,
}

type QuantBinding {
    name: Ident,
    kind: QuantBindingKind,
    span: Span,
}

// Rust: pub enum QuantBindingKind { InCollection(Expr), Typed(TypeRef) }
enum QuantBindingKind {
    // x in collection - carries Expression
    InCollection,
    // x: Type - carries TypeRef
    Typed,
}

// ============================================================================
// Lambdas and Calls
// ============================================================================

type LambdaParam {
    name: Ident,
    ty: Option<TypeRef>,
}

type FieldInit {
    name: Ident,
    value: Expression,
    span: Span,
}

// ============================================================================
// Match and Patterns
// ============================================================================

type MatchArm {
    pattern: Pattern,
    guard: Option<Expression>,
    body: Expression,
    span: Span,
}

type Pattern {
    kind: PatternKind,
    span: Span,
}

enum PatternKind {
    // Wildcard: _
    Wildcard,
    // Literal pattern: 42, "hello", true
    Literal,
    // Binding pattern: x, name
    Binding,
    // Variant pattern: Some(x), None
    Variant,
    // Struct pattern: User { id, name }
    Struct,
    // Tuple pattern: (a, b, c)
    Tuple,
    // Or pattern: A | B
    Or,
}

type FieldPattern {
    name: Ident,
    pattern: Option<Pattern>,
    span: Span,
}

// Note: Conceptual type - in Rust, block is ExprKind::Block(Vec<Expr>)
type BlockExpression {
    statements: List<Expression>,
    span: Span,
}

// ============================================================================
// Specification (top-level)
// ============================================================================

// A qualified path like "common::types::Email" or "abc.def.ghi"
type Path {
    segments: List<Ident>,
    span: Span,
}

type Module {
    // Module path supports dotted paths (e.g., "abc.def")
    path: Path,
    span: Span,
}

// Import statement: use path::to::module::{Item, AnotherItem as Alias}
type Import {
    path: Path,
    items: Option<List<ImportItem>>,
    span: Span,
}

type ImportItem {
    name: Ident,
    alias: Option<Ident>,
}

// Resolved import after cross-module resolution
type ResolvedImport {
    source_module: String,
    items: List<ImportedItem>,
}

type ImportedItem {
    original_name: String,
    local_name: String,
}

// Module registry for tracking definitions across files
type ModuleRegistry {
    modules: Map<String, ModuleInfo>,
    current_module: Option<String>,
}

type ModuleInfo {
    name: String,
    types: Set<String>,
    enums: Set<String>,
    states: Set<String>,
    actions: Set<String>,
    relations: Set<String>,
    imports: List<ResolvedImport>,
}

// ============================================================================
// Quality Requirements (NFRs)
// ============================================================================

type Quality {
    attributes: List<Attribute>,
    category: QualityCategory,
    description: String,
    metric: Ident,
    scale: Option<Scale>,
    target: QualityTarget,
    constraint: Option<Constraint>,
    applies_to: Option<AppliesTo>,
    measurement: Option<MeasurementPeriod>,
    under_load: Option<LoadConditions>,
    verified_by: List<VerificationMethod>,
    properties: List<QualityProperty>,
    span: Span,
}

enum QualityCategory {
    Performance,
    Reliability,
    Security,
    Usability,
    Scalability,
    Maintainability,
}

enum Scale {
    Mean,
    Median,
    P50,
    P90,
    P95,
    P99,
    P999,
    Max,
    Min,
}

enum Constraint {
    Hard,
    Soft,
}

type QualityTarget {
    op: QualityOp,
    value: QualityValue,
    span: Span,
}

enum QualityOp {
    Lt,
    LtEq,
    Gt,
    GtEq,
    Eq,
}

// Quality value with associated data
// Rust: pub enum QualityValue { Int(i64), Percentage(f64), Duration(i64, DurationUnit), Size(i64, SizeUnit), Rate(i64, RateUnit), Expr(Expr) }
enum QualityValue {
    // Integer value: 1000 - carries Int
    Int,
    // Percentage value: 99.9% - carries Float
    Percentage,
    // Duration value: 100ms, 5s - carries (Int, DurationUnit)
    Duration,
    // Size value: 1KB, 10MB - carries (Int, SizeUnit)
    Size,
    // Rate value: 1000/s, 50/min - carries (Int, RateUnit)
    Rate,
    // Expression for computed values - carries Expression
    Expr,
}

type AppliesTo {
    kind: AppliesToKind,
    name: Ident,
    span: Span,
}

enum AppliesToKind {
    Action,
    Type,
    State,
}

enum MeasurementPeriod {
    PerRequest,
    PerSecond,
    PerMinute,
    Hourly,
    Daily,
    Weekly,
    Monthly,
}

type LoadConditions {
    concurrent_users: Option<Int>,
    concurrent_connections: Option<Int>,
    requests_per_second: Option<Int>,
    // Tuple: (value, unit) for size with unit
    payload_size: Option<(Int, SizeUnit)>,
    // Tuple: (value, unit) for duration with unit
    duration: Option<(Int, DurationUnit)>,
    span: Span,
}

// Duration units for quality values
enum DurationUnit {
    Ms,     // milliseconds
    S,      // seconds
    M,      // minutes
    H,      // hours
}

// Size units for quality values
enum SizeUnit {
    Kb,     // kilobytes
    Mb,     // megabytes
    Gb,     // gigabytes
    Tb,     // terabytes
}

// Rate units for quality values
enum RateUnit {
    PerSecond,
    PerMinute,
    PerHour,
}

type VerificationMethod {
    kind: VerificationKind,
    name: String,
    span: Span,
}

enum VerificationKind {
    Test,
    Monitor,
    Benchmark,
    Audit,
}

type QualityProperty {
    name: Ident,
    value: QualityPropertyValue,
    span: Span,
}

enum QualityPropertyValue {
    // Identifier value (e.g., scale: p95) - carries Ident
    Ident,
    // Target value (e.g., constraint: < 500ms) - carries QualityTarget
    Target,
    // Applies to reference (e.g., applies_to: action create_user) - carries AppliesTo
    AppliesTo,
}

type Specification {
    module: Option<Module>,
    imports: List<Import>,
    types: List<TypeDef>,
    type_aliases: List<TypeAlias>,
    enums: List<EnumDef>,
    relations: List<Relation>,
    states: List<StateBlock>,
    actions: List<Action>,
    scenarios: List<Scenario>,
    properties: List<Property>,
    qualities: List<Quality>,
}
