// Fastbreak Self-Specification
// A formal specification of Fastbreak's own domain model
module fastbreak

// ============================================================================
// Core Types
// ============================================================================

type Identifier {
    name: String,
}

type Span {
    start: Int,
    end: Int,
}

enum PrimitiveType {
    Int,
    String,
    Bool,
    Float,
}

// ============================================================================
// Type System
// ============================================================================

type TypeRef {
    name: Identifier,
    generics: List<TypeRef>,
    span: Span,
}

type Field {
    name: Identifier,
    field_type: TypeRef,
    refinement: Option<Expression>,
    span: Span,
}

type TypeDefinition {
    name: Identifier,
    fields: List<Field>,
    span: Span,
}

type EnumVariant {
    name: Identifier,
    span: Span,
}

type EnumDefinition {
    name: Identifier,
    variants: List<EnumVariant>,
    span: Span,
}

type TypeAlias {
    name: Identifier,
    target: TypeRef,
    refinement: Option<Expression>,
    span: Span,
}

// ============================================================================
// State and Actions
// ============================================================================

type StateField {
    name: Identifier,
    field_type: TypeRef,
    initial_value: Option<Expression>,
    span: Span,
}

type Invariant {
    description: Option<String>,
    expression: Expression,
    span: Span,
}

type StateDefinition {
    name: Identifier,
    fields: List<StateField>,
    invariants: List<Invariant>,
    span: Span,
}

type Parameter {
    name: Identifier,
    param_type: TypeRef,
    span: Span,
}

enum ContractKind {
    Requires,
    Ensures,
}

type Contract {
    kind: ContractKind,
    expression: Expression,
    span: Span,
}

type ActionDefinition {
    name: Identifier,
    parameters: List<Parameter>,
    return_type: Option<TypeRef>,
    contracts: List<Contract>,
    span: Span,
}

// ============================================================================
// Scenarios
// ============================================================================

type Binding {
    name: Identifier,
    value: Expression,
    span: Span,
}

type Assertion {
    expression: Expression,
    description: Option<String>,
    span: Span,
}

type GivenClause {
    bindings: List<Binding>,
    span: Span,
}

type WhenClause {
    bindings: List<Binding>,
    span: Span,
}

type ThenClause {
    assertions: List<Assertion>,
    span: Span,
}

type Alternative {
    name: String,
    condition: Option<Expression>,
    given: Option<GivenClause>,
    when: Option<WhenClause>,
    then_clause: ThenClause,
    span: Span,
}

type Scenario {
    description: String,
    given: GivenClause,
    when_clause: WhenClause,
    then_clause: ThenClause,
    alternatives: List<Alternative>,
    span: Span,
}

// ============================================================================
// Properties
// ============================================================================

enum TemporalOperator {
    Always,
    Eventually,
}

type Property {
    description: String,
    temporal_op: Option<TemporalOperator>,
    expression: Expression,
    span: Span,
}

// ============================================================================
// Expressions (simplified)
// ============================================================================

type Expression {
    kind: ExpressionKind,
    span: Span,
}

enum ExpressionKind {
    Literal,
    Identifier,
    BinaryOp,
    UnaryOp,
    Call,
    FieldAccess,
    Quantifier,
    Match,
    Block,
}

type MatchArm {
    pattern: Pattern,
    guard: Option<Expression>,
    body: Expression,
    span: Span,
}

type Pattern {
    kind: PatternKind,
    span: Span,
}

enum PatternKind {
    Wildcard,
    Literal,
    Identifier,
    Variant,
    Struct,
}

type BlockExpression {
    statements: List<Expression>,
    span: Span,
}

// ============================================================================
// Specification (top-level)
// ============================================================================

// Module path for dotted names like "abc.def.ghi"
type ModulePath {
    segments: List<Identifier>,
    span: Span,
}

type Module {
    // Module name supports dotted paths (e.g., "abc.def")
    name: ModulePath,
    span: Span,
}

// Import statement: use path::to::module::{Item, AnotherItem as Alias}
type Import {
    path: ModulePath,
    items: Option<List<ImportItem>>,
    span: Span,
}

type ImportItem {
    name: Identifier,
    alias: Option<Identifier>,
    span: Span,
}

// Resolved import after cross-module resolution
type ResolvedImport {
    source_module: String,
    items: List<ImportedItem>,
}

type ImportedItem {
    original_name: String,
    local_name: String,
}

// Module registry for tracking definitions across files
type ModuleRegistry {
    modules: Map<String, ModuleInfo>,
    current_module: Option<String>,
}

type ModuleInfo {
    name: String,
    types: Set<String>,
    enums: Set<String>,
    states: Set<String>,
    actions: Set<String>,
    imports: List<ResolvedImport>,
}

type Specification {
    module: Option<Module>,
    imports: List<Import>,
    types: List<TypeDefinition>,
    enums: List<EnumDefinition>,
    type_aliases: List<TypeAlias>,
    states: List<StateDefinition>,
    actions: List<ActionDefinition>,
    scenarios: List<Scenario>,
    properties: List<Property>,
}

// ============================================================================
// State: Compiler Pipeline
// ============================================================================

state CompilerPipeline {
    source_files: Set<String>,
    parsed_specs: Map<String, Specification>,
    errors: List<String>,

    invariant "All parsed specs have source files" {
        forall path in parsed_specs.keys() =>
            path in source_files
    }
}

// ============================================================================
// Actions: Compiler Operations
// ============================================================================

action parse(source: String) -> Result<Specification, String>
    ensures {
        match result {
            Ok(spec) => spec.types.len() >= 0,
            Err(msg) => msg.len() > 0,
        }
    }

action analyze(spec: Specification) -> List<String>
    ensures {
        // Returns list of semantic errors (empty if valid)
        result.len() >= 0
    }

action compile(spec: Specification) -> CompiledSpec
    requires {
        // Specification must pass semantic analysis
        analyze(spec).len() == 0
    }

action generate_markdown(spec: CompiledSpec) -> String
    ensures {
        result.len() > 0
    }

action generate_diagram(spec: CompiledSpec, diagram_type: DiagramType) -> String
    ensures {
        result.len() > 0
    }

action build_module_registry(specs: List<Specification>) -> ModuleRegistry
    ensures {
        // All modules from input specs are registered
        forall spec in specs where spec.module is Some =>
            result.modules.contains_key(spec.module.unwrap().name)
    }

action resolve_imports(registry: ModuleRegistry, module_name: String) -> List<String>
    requires {
        registry.modules.contains_key(module_name)
    }
    ensures {
        // Returns list of unresolved import errors (empty if all resolved)
        result.len() >= 0
    }

// ============================================================================
// Supporting Types for Actions
// ============================================================================

type CompiledSpec {
    name: String,
    structs: List<CompiledStruct>,
    enums: List<CompiledEnum>,
    states: List<CompiledState>,
    actions: List<CompiledAction>,
    scenarios: List<CompiledScenario>,
    properties: List<CompiledProperty>,
}

type CompiledStruct {
    name: String,
    fields: List<CompiledField>,
}

type CompiledField {
    name: String,
    field_type: String,
}

type CompiledEnum {
    name: String,
    variants: List<String>,
}

type CompiledState {
    name: String,
    fields: List<CompiledField>,
    invariants: List<String>,
}

type CompiledAction {
    name: String,
    parameters: List<CompiledField>,
    return_type: Option<String>,
    preconditions: List<String>,
    postconditions: List<String>,
}

type CompiledScenario {
    description: String,
    given: List<String>,
    when_action: List<String>,
    then_assertions: List<String>,
}

type CompiledProperty {
    description: String,
    temporal_op: Option<String>,
    expression: String,
}

enum DiagramType {
    Erd,
    State,
    Sequence,
}

// ============================================================================
// Scenarios: Usage Examples
// ============================================================================

scenario "Parse a simple type definition" {
    given {
        source = "type User { id: Int, name: String }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().types.len() == 1
    }
}

scenario "Parse a state with invariant" {
    given {
        // Note: Source contains a state with invariant
        source = "state System { users: Set<User> }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().states.len() == 1
    }
}

scenario "Parse dotted module name" {
    given {
        source = "module abc.def.ghi\n\ntype User { id: Int }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
        result.unwrap().module is Some
        result.unwrap().module.unwrap().name.segments.len() == 3
    }
}

scenario "Generate documentation from compiled spec" {
    given {
        spec = CompiledSpec {
            name: "test",
            structs: [],
            enums: [],
            states: [],
            actions: [],
            scenarios: [],
            properties: [],
        }
    }
    when {
        markdown = generate_markdown(spec)
    }
    then {
        markdown.len() > 0
    }
}

scenario "Cross-file type import" {
    given {
        // File 1: defines shared types
        types_file = "module types\n\ntype UserId { value: Int }\ntype Email { address: String }"
        // File 2: imports and uses the types
        users_file = "module users\n\nuse types::{UserId, Email}\n\ntype User { id: UserId, email: Email }"
    }
    when {
        types_spec = parse(types_file)
        users_spec = parse(users_file)
        registry = build_module_registry([types_spec.unwrap(), users_spec.unwrap()])
    }
    then {
        // UserId and Email should be available in the users module
        registry.is_type_available("users", "UserId")
        registry.is_type_available("users", "Email")
        registry.is_type_available("users", "User")
    }
}

scenario "Import with alias" {
    given {
        types_file = "module types\n\ntype Identifier { value: String }"
        users_file = "module users\n\nuse types::{Identifier as Id}\n\ntype User { id: Id }"
    }
    when {
        types_spec = parse(types_file)
        users_spec = parse(users_file)
        registry = build_module_registry([types_spec.unwrap(), users_spec.unwrap()])
    }
    then {
        // Id should be available (aliased from Identifier)
        registry.is_type_available("users", "Id")
    }
}

// ============================================================================
// Properties: System Guarantees
// ============================================================================

property "Parsing is deterministic" {
    always {
        forall source: String =>
            parse(source) == parse(source)
    }
}

property "Valid specs produce no errors" {
    always {
        forall spec: Specification where analyze(spec).len() == 0 =>
            compile(spec) is Ok
    }
}

property "Type names are unique within a specification" {
    always {
        forall spec: Specification, t1, t2 in spec.types where t1 != t2 =>
            t1.name != t2.name
    }
}

property "Imported types must exist in source module" {
    always {
        forall registry: ModuleRegistry, import in registry.current_module_info().imports =>
            forall item in import.items =>
                registry.get_module(import.source_module).types.contains(item.original_name)
    }
}

// ============================================================================
// Error Reporting
// ============================================================================

type SourceLocation {
    line: Int,
    column: Int,
}

type ErrorContext {
    path: String,
    source: String,
    location: SourceLocation,
}

enum ErrorKind {
    Parse,
    Semantic,
    Io,
}

type CompilerError {
    kind: ErrorKind,
    message: String,
    context: Option<ErrorContext>,
}

action compute_location(source: String, byte_offset: Int) -> SourceLocation
    requires {
        byte_offset >= 0 and byte_offset <= source.len()
    }
    ensures {
        result.line >= 1 and result.column >= 1
    }

action format_error(error: CompilerError) -> String
    ensures {
        // Error messages must include location when context is available
        match error.context {
            Some(ctx) => result.contains(ctx.location.line.to_string()),
            None => true,
        }
    }

scenario "Parse match with block body" {
    given {
        source = "state Test { x: Int, invariant { match x { 0 => { false }, _ => { x > 0 } } } }"
    }
    when {
        result = parse(source)
    }
    then {
        result is Ok
    }
}

scenario "Parse error includes line number" {
    given {
        source = "type User {\n    id: Int,\n    invalid syntax\n}"
    }
    when {
        result = parse(source)
    }
    then {
        result is Err
        // Error message should contain line number
    }
}

property "All errors with spans have valid line numbers" {
    always {
        forall error: CompilerError where error.context is Some =>
            error.context.unwrap().location.line >= 1
    }
}

// ============================================================================
// Quality Requirements
// ============================================================================

@id("NFR-001")
quality performance "Parse time for typical specs" {
    metric: latency,
    target: < 100ms,
}

@id("NFR-002")
quality reliability "Parser handles malformed input gracefully" {
    metric: error_handling,
    target: == 100%,
}

@id("NFR-003")
quality maintainability "Code coverage" {
    metric: test_coverage,
    target: >= 80%,
}
