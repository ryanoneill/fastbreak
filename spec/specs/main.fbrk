// Fastbreak Self-Specification
// A formal specification of Fastbreak's own domain model
module fastbreak

// ============================================================================
// Core Types
// ============================================================================

// An identifier with source location
type Ident {
    name: String,
    span: Span,
}

type Span {
    start: Int,
    end: Int,
}

enum PrimitiveType {
    Int,
    String,
    Bool,
    Float,
}

// ============================================================================
// Attributes
// ============================================================================

// Attribute on definitions: @id("REQ-001"), @deprecated, @since("1.0")
type Attribute {
    name: Ident,
    args: List<AttributeArg>,
    span: Span,
}

// Argument to an attribute
enum AttributeArg {
    // String argument: @id("REQ-001")
    StringArg,
    // Identifier argument: @category(security)
    IdentArg,
    // Integer argument: @priority(1)
    IntArg,
}

type StringAttributeArg {
    value: String,
}

type IdentAttributeArg {
    value: Ident,
}

type IntAttributeArg {
    value: Int,
}

// ============================================================================
// Type System
// ============================================================================

// Built-in types provided by the language
enum BuiltInType {
    Int,
    String,
    Bool,
    Set,
    Map,
    List,
    Option,
    Result,
}

type TypeRef {
    kind: TypeRefKind,
    span: Span,
}

// Kind of type reference
enum TypeRefKind {
    // A simple type name or path: User, common::types::Email
    Named,
    // A built-in type: Int, String, Bool
    BuiltIn,
    // A generic type with arguments: Set<User>, Map<String, Int>
    Generic,
    // A function type: (A, B) -> C
    Function,
    // A tuple type: (A, B)
    Tuple,
    // Unit type: ()
    Unit,
}

type GenericArg {
    ty: TypeRef,
}

type Field {
    name: Ident,
    ty: TypeRef,
    span: Span,
}

type TypeDef {
    attributes: List<Attribute>,
    name: Ident,
    type_params: List<Ident>,
    fields: List<Field>,
    refinement: Option<Expression>,
    span: Span,
}

type EnumVariant {
    name: Ident,
    fields: List<Field>,
    span: Span,
}

type EnumDef {
    attributes: List<Attribute>,
    name: Ident,
    type_params: List<Ident>,
    variants: List<EnumVariant>,
    span: Span,
}

type TypeAlias {
    attributes: List<Attribute>,
    name: Ident,
    type_params: List<Ident>,
    base: TypeRef,
    refinement: Option<Expression>,
    span: Span,
}

// ============================================================================
// Relations
// ============================================================================

// Relation definition: relation friends: User -> Set<User> { symmetric }
type Relation {
    attributes: List<Attribute>,
    name: Ident,
    source: TypeRef,
    target: TypeRef,
    constraints: List<RelationConstraint>,
    span: Span,
}

// Constraints on relations (Alloy-inspired)
enum RelationConstraint {
    // The relation is symmetric: a R b implies b R a
    Symmetric,
    // The relation is reflexive: a R a for all a
    Reflexive,
    // The relation is irreflexive: not (a R a) for all a
    Irreflexive,
    // The relation is transitive: a R b and b R c implies a R c
    Transitive,
    // The relation is antisymmetric: a R b and b R a implies a = b
    Antisymmetric,
}

// ============================================================================
// State and Actions
// ============================================================================

type StateField {
    name: Ident,
    ty: TypeRef,
    init: Option<Expression>,
    span: Span,
}

type Invariant {
    attributes: List<Attribute>,
    description: Option<String>,
    expr: Expression,
    span: Span,
}

type StateBlock {
    attributes: List<Attribute>,
    name: Ident,
    fields: List<StateField>,
    invariants: List<Invariant>,
    span: Span,
}

type ActionParam {
    name: Ident,
    ty: TypeRef,
    span: Span,
}

enum ContractKind {
    Requires,
    Ensures,
}

type Contract {
    kind: ContractKind,
    expr: Expression,
    span: Span,
}

type Action {
    attributes: List<Attribute>,
    name: Ident,
    params: List<ActionParam>,
    return_type: Option<TypeRef>,
    contracts: List<Contract>,
    body: Option<Expression>,
    span: Span,
}

// ============================================================================
// Scenarios
// ============================================================================

type Binding {
    name: Ident,
    value: Expression,
    span: Span,
}

type Assertion {
    expr: Expression,
    description: Option<String>,
    span: Span,
}

type GivenClause {
    bindings: List<Binding>,
    span: Span,
}

type WhenClause {
    bindings: List<Binding>,
    span: Span,
}

type ThenClause {
    assertions: List<Assertion>,
    span: Span,
}

type Alternative {
    attributes: List<Attribute>,
    name: String,
    condition: Option<Expression>,
    given: Option<GivenClause>,
    when: Option<WhenClause>,
    then: ThenClause,
    span: Span,
}

type Scenario {
    attributes: List<Attribute>,
    description: String,
    given: GivenClause,
    when: WhenClause,
    then: ThenClause,
    alternatives: List<Alternative>,
    span: Span,
}

// ============================================================================
// Properties
// ============================================================================

enum TemporalOp {
    Always,
    Eventually,
}

type Property {
    attributes: List<Attribute>,
    description: String,
    temporal_op: Option<TemporalOp>,
    expr: Expression,
    span: Span,
}

// ============================================================================
// Expressions
// ============================================================================

type Expression {
    kind: ExpressionKind,
    span: Span,
}

// Full enumeration of expression kinds
enum ExpressionKind {
    // Literals: integers, strings, booleans, unit
    Literal,
    // Variable or path reference: x, user.email
    Var,
    // Binary operation: left op right
    Binary,
    // Unary operation: op expr
    Unary,
    // Function call: f(args)
    Call,
    // Method call with receiver: users.map(u => u.id)
    MethodCall,
    // Field access: expr.field
    Field,
    // Index access: expr[index]
    Index,
    // Match expression: match expr { arms }
    Match,
    // If expression: if cond { then } else { else }
    If,
    // Block expression: { stmts; expr }
    Block,
    // List literal: [a, b, c]
    List,
    // Set literal: {a, b, c}
    Set,
    // Map literal: {k1: v1, k2: v2}
    Map,
    // Struct literal: Type { field: value }
    Struct,
    // Tuple literal: (a, b, c)
    Tuple,
    // Lambda: |params| body or x => body
    Lambda,
    // Let binding: let x = expr in body
    Let,
    // Universal quantifier: forall x in xs => pred(x)
    Forall,
    // Existential quantifier: exists x in xs => pred(x)
    Exists,
    // Implication: a implies b
    Implies,
    // Range: start..end
    Range,
    // Type/pattern check: expr is Type or expr is Ok(value)
    Is,
    // Old value in postcondition: old(expr)
    Old,
    // Next state value: expr'
    Prime,
    // Result value in postconditions
    Result,
    // Self reference in refinement predicates
    SelfRef,
}

// ============================================================================
// Operators
// ============================================================================

enum BinaryOp {
    // Arithmetic operators
    Add,        // +
    Sub,        // -
    Mul,        // *
    Div,        // /
    Mod,        // %
    // Comparison operators
    Eq,         // ==
    NotEq,      // !=
    Lt,         // <
    LtEq,       // <=
    Gt,         // >
    GtEq,       // >=
    // Logical operators
    And,        // and
    Or,         // or
    Implies,    // =>
    // Set/collection operators
    In,         // in
    Union,      // union
    Intersect,  // intersect
    Difference, // difference / setminus
}

enum UnaryOp {
    // Logical negation: not expr
    Not,
    // Arithmetic negation: -expr
    Neg,
}

// ============================================================================
// Literals
// ============================================================================

enum Literal {
    // Integer literal: 42, -1
    Int,
    // String literal: "hello"
    StringLit,
    // Boolean literal: true, false
    Bool,
    // Unit/empty tuple: ()
    Unit,
}

type IntLiteral {
    value: Int,
}

type StringLiteral {
    value: String,
}

type BoolLiteral {
    value: Bool,
}

// ============================================================================
// Quantifiers
// ============================================================================

enum QuantifierKind {
    // Universal: forall x in xs => predicate
    ForAll,
    // Existential: exists x in xs where predicate
    Exists,
}

type QuantBinding {
    name: Ident,
    kind: QuantBindingKind,
    span: Span,
}

enum QuantBindingKind {
    // x in collection
    InCollection,
    // x: Type
    Typed,
}

// ============================================================================
// Lambdas and Calls
// ============================================================================

type LambdaParam {
    name: Ident,
    param_type: Option<TypeRef>,
}

type FieldInit {
    name: Ident,
    value: Expression,
    span: Span,
}

// ============================================================================
// Match and Patterns
// ============================================================================

type MatchArm {
    pattern: Pattern,
    guard: Option<Expression>,
    body: Expression,
    span: Span,
}

type Pattern {
    kind: PatternKind,
    span: Span,
}

enum PatternKind {
    // Wildcard: _
    Wildcard,
    // Literal pattern: 42, "hello", true
    Literal,
    // Binding pattern: x, name
    Binding,
    // Variant pattern: Some(x), None
    Variant,
    // Struct pattern: User { id, name }
    Struct,
    // Tuple pattern: (a, b, c)
    Tuple,
    // Or pattern: A | B
    Or,
}

type FieldPattern {
    name: Ident,
    pattern: Option<Pattern>,
    span: Span,
}

type BlockExpression {
    statements: List<Expression>,
    span: Span,
}

// ============================================================================
// Specification (top-level)
// ============================================================================

// A qualified path like "common::types::Email" or "abc.def.ghi"
type Path {
    segments: List<Ident>,
    span: Span,
}

type Module {
    // Module path supports dotted paths (e.g., "abc.def")
    path: Path,
    span: Span,
}

// Import statement: use path::to::module::{Item, AnotherItem as Alias}
type Import {
    path: Path,
    items: Option<List<ImportItem>>,
    span: Span,
}

type ImportItem {
    name: Ident,
    alias: Option<Ident>,
}

// Resolved import after cross-module resolution
type ResolvedImport {
    source_module: String,
    items: List<ImportedItem>,
}

type ImportedItem {
    original_name: String,
    local_name: String,
}

// Module registry for tracking definitions across files
type ModuleRegistry {
    modules: Map<String, ModuleInfo>,
    current_module: Option<String>,
}

type ModuleInfo {
    name: String,
    types: Set<String>,
    enums: Set<String>,
    states: Set<String>,
    actions: Set<String>,
    imports: List<ResolvedImport>,
}

type Specification {
    module: Option<Module>,
    imports: List<Import>,
    types: List<TypeDef>,
    type_aliases: List<TypeAlias>,
    enums: List<EnumDef>,
    relations: List<Relation>,
    states: List<StateBlock>,
    actions: List<Action>,
    scenarios: List<Scenario>,
    properties: List<Property>,
    qualities: List<Quality>,
}
